#!/usr/bin/env python3
# Standard library imports
import os
import sys
import json
import logging
import time
import argparse
from typing import Dict, Any, Optional, Tuple, List

# Third-party imports
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from web3 import Web3, HTTPProvider
from web3.exceptions import ContractLogicError
from dotenv import load_dotenv

# Configure logging with more detail and file output
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("uncertainty_analytics.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Load environment variables
logger.info("Loading environment variables...")
load_dotenv()


def get_uncertainty_analytics_abi():
    """
    Returns the comprehensive ABI for the UncertaintyAnalytics contract
    """
    return [
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_processingTime",
                    "type": "uint256"
                }
            ],
            "name": "calculateUnavailabilityCost",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "contract UncertaintyBase",
                    "name": "_base",
                    "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "uint256",
                    "name": "requestId",
                    "type": "uint256"
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "cost",
                    "type": "uint256"
                },
                {
                    "indexed": False,
                    "internalType": "string",
                    "name": "costType",
                    "type": "string"
                }
            ],
            "name": "CostRecorded",
            "type": "event"
        },
        {
            "inputs": [],
            "name": "dataHoldingCost",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "disruptionLevel",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "escalationLevel",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "unavailabilityCost",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_cost",
                    "type": "uint256"
                }
            ],
            "name": "updateDataHoldingCost",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_level",
                    "type": "uint256"
                }
            ],
            "name": "updateDisruptionLevel",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_level",
                    "type": "uint256"
                }
            ],
            "name": "updateEscalationLevel",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "getMetrics",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "avgProcessingTime",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "successRate",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "totalCost",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "disruptionCount",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "requestId",
                    "type": "uint256"
                },
                {
                    "internalType": "string",
                    "name": "reason",
                    "type": "string"
                }
            ],
            "name": "recordFailedTransaction",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ]


def get_request_manager_abi():
    """
    Returns the comprehensive ABI for the RequestManager contract
    """
    return [
        {
            "inputs": [
                {
                    "internalType": "address", 
                    "name": "_analytics", 
                    "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "recipient",
                    "type": "address"
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "FundsWithdrawn",
            "type": "event"
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "uint256",
                    "name": "requestId",
                    "type": "uint256"
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "requester",
                    "type": "address"
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "value",
                    "type": "uint256"
                }
            ],
            "name": "RequestSubmitted",
            "type": "event"
        },
        {
            "inputs": [],
            "name": "submitRequest",
            "outputs": [
                {
                    "internalType": "uint256", 
                    "name": "", 
                    "type": "uint256"
                }
            ],
            "stateMutability": "payable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "string", 
                    "name": "_additionalInfo", 
                    "type": "string"
                }
            ],
            "name": "submitRequestWithInfo",
            "outputs": [
                {
                    "internalType": "uint256", 
                    "name": "", 
                    "type": "uint256"
                }
            ],
            "stateMutability": "payable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_newOwner",
                    "type": "address"
                }
            ],
            "name": "transferOwnership",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "withdraw",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "stateMutability": "payable",
            "type": "receive"
        },
        {
            "inputs": [],
            "name": "getAnalyticsMetrics",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "avgProcessingTime",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "successRate",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "totalCost",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "disruptionCount",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "owner",
            "outputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "VERSION",
            "outputs": [
                {
                    "internalType": "string",
                    "name": "",
                    "type": "string"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ]


def get_response_manager_abi():
    """
    Returns the comprehensive ABI for the ResponseManager contract
    """
    return [
        {
            "inputs": [
                {
                    "internalType": "address", 
                    "name": "_analytics", 
                    "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "recipient",
                    "type": "address"
                },
                {
                    "indexed": False,
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "FundsWithdrawn",
            "type": "event"
        },
        {
            "anonymous": False,
            "inputs": [
                {
                    "indexed": True,
                    "internalType": "uint256",
                    "name": "requestId",
                    "type": "uint256"
                },
                {
                    "indexed": True,
                    "internalType": "address",
                    "name": "responder",
                    "type": "address"
                }
            ],
            "name": "ResponseSubmitted",
            "type": "event"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256", 
                    "name": "_requestId", 
                    "type": "uint256"
                }
            ],
            "name": "submitResponse",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256", 
                    "name": "_requestId", 
                    "type": "uint256"
                }
            ],
            "name": "submitResponseWithCalculation",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_newOwner",
                    "type": "address"
                }
            ],
            "name": "transferOwnership",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "withdraw",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "stateMutability": "payable",
            "type": "receive"
        },
        {
            "inputs": [],
            "name": "VERSION",
            "outputs": [
                {
                    "internalType": "string",
                    "name": "",
                    "type": "string"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "getAnalyticsMetrics",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "avgProcessingTime",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "successRate",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "totalCost",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "disruptionCount",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_responder",
                    "type": "address"
                }
            ],
            "name": "getResponderCount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "count",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "owner",
            "outputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "name": "processedRequests",
            "outputs": [
                {
                    "internalType": "bool",
                    "name": "",
                    "type": "bool"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "",
                    "type": "address"
                }
            ],
            "name": "responderCount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ]


def create_web3_connection(network: str = "sepolia") -> Tuple[Web3, Any]:
    """
    Create a Web3 connection to the specified network
    Returns a tuple of (web3, account)
    """
    try:
        # Retrieve Infura Project ID from environment variables
        INFURA_PROJECT_ID = os.getenv("INFURA_PROJECT_ID")
        PRIVATE_KEY = os.getenv("PRIVATE_KEY")

        if not INFURA_PROJECT_ID:
            logger.error("INFURA_PROJECT_ID not found in environment variables")
            raise ValueError("INFURA_PROJECT_ID not found in environment variables")
        if not PRIVATE_KEY:
            logger.error("PRIVATE_KEY not found in environment variables")
            raise ValueError("PRIVATE_KEY not found in environment variables")

        # Construct Infura URL based on network
        network_urls = {
            "mainnet": f"https://mainnet.infura.io/v3/{INFURA_PROJECT_ID}",
            "sepolia": f"https://sepolia.infura.io/v3/{INFURA_PROJECT_ID}",
            "goerli": f"https://goerli.infura.io/v3/{INFURA_PROJECT_ID}",
            "arbitrum": f"https://arbitrum-mainnet.infura.io/v3/{INFURA_PROJECT_ID}",
            "optimism": f"https://optimism-mainnet.infura.io/v3/{INFURA_PROJECT_ID}"
        }
        
        if network.lower() not in network_urls:
            logger.error(f"Unsupported network: {network}")
            raise ValueError(f"Unsupported network: {network}. Supported networks: {', '.join(network_urls.keys())}")
            
        provider_url = network_urls[network.lower()]
        logger.debug(f"Connecting to {network} via Infura: {provider_url}")

        # Create Web3 instance
        web3 = Web3(HTTPProvider(provider_url))

        # Check connection
        if not web3.is_connected():
            logger.error(f"Failed to connect to Infura {network} endpoint")
            raise ConnectionError(f"Failed to connect to Infura {network} endpoint")

        # Create account from private key
        account = web3.eth.account.from_key(PRIVATE_KEY)
        web3.eth.default_account = account.address
        logger.debug(f"Set default account to: {web3.eth.default_account}")

        logger.info("\n--- Blockchain Connection Details ---")
        logger.info(f"Connected to Network: {network}")
        logger.info(f"Chain ID: {web3.eth.chain_id}")
        logger.info(f"Latest Block Number: {web3.eth.block_number}")
        logger.info(f"Default Account: {web3.eth.default_account}")
        balance = Web3.from_wei(web3.eth.get_balance(web3.eth.default_account), 'ether')
        logger.info(f"Account Balance: {balance} ETH")

        return web3, account

    except Exception as e:
        logger.error(f"Blockchain Connection Error: {e}", exc_info=True)
        raise


def validate_env_variables() -> bool:
    """
    Validate that all necessary environment variables are set
    """
    required_vars = ["INFURA_PROJECT_ID", "PRIVATE_KEY"]
    
    for var in required_vars:
        if not os.getenv(var):
            logger.error(f"Missing required environment variable: {var}")
            print(f"ERROR: Missing required environment variable: {var}")
            print(f"Please set {var} in your .env file or environment.")
            return False
    
    logger.info("All required environment variables are set")
    return True


def display_contract_info(manager) -> None:
    """
    Display contract information for the UncertaintyAnalyticsManager
    """
    print("\n=== Contract Information ===")
    print(f"Uncertainty Analytics Contract: {manager.uncertainty_address}")
    print(f"Request Manager Contract: {manager.request_manager_address}")
    print(f"Response Manager Contract: {manager.response_manager_address}")
    print(f"Connected Account: {manager.w3.eth.default_account}")
    balance = Web3.from_wei(manager.w3.eth.get_balance(manager.w3.eth.default_account), 'ether')
    print(f"Account Balance: {balance} ETH")


class UncertaintyAnalyticsManager:
    def __init__(
        self, 
        web3: Web3, 
        uncertainty_address: str,
        request_manager_address: str,
        response_manager_address: str,
        build_contracts_dir: Optional[str] = None,
        project_root: Optional[str] = None
    ):
        """Initialize Uncertainty Analytics Manager"""
        logger.info("Initializing UncertaintyAnalyticsManager...")
        
        # Determine project root and default paths
        self.project_root = project_root or os.path.abspath(
            os.path.join(os.path.dirname(__file__), "..")
        )

        # Build contracts directory
        self.build_contracts_dir = build_contracts_dir or os.path.join(
            self.project_root, "build", "contracts"
        )

        # Blockchain connection
        self.w3 = web3
        self.logger = logger
        logger.debug(f"Web3 connected: {self.w3.is_connected()}")
        logger.debug(f"Web3 chain ID: {self.w3.eth.chain_id}")

        # Contract addresses
        self.uncertainty_address = Web3.to_checksum_address(uncertainty_address)
        self.request_manager_address = Web3.to_checksum_address(request_manager_address)
        self.response_manager_address = Web3.to_checksum_address(response_manager_address)
        
        # Contract instances
        self.uncertainty_contract = None
        self.request_manager_contract = None
        self.response_manager_contract = None
        
        # ABIs with comprehensive contract definitions
        logger.debug("Loading contract ABIs...")
        self.uncertainty_abi = get_uncertainty_analytics_abi()
        self.request_manager_abi = get_request_manager_abi()
        self.response_manager_abi = get_response_manager_abi()
        
        # Load all contracts
        self.load_contracts()
        
        # Simulation data
        self.mock_requests = {}
        self.mock_responses = {}
        self.mock_processed_requests = set()
        self.mock_responder_count = {}
        self.mock_metrics = {
            "avgProcessingTime": 0,
            "successRate": 100,
            "totalCost": Web3.to_wei(0, 'ether'),
            "disruptionCount": 0
        }
        self.next_request_id = 1
        
        # Constants from contracts
        self.BASE_COST = Web3.to_wei(0.001, 'ether')
        self.MAX_PROCESSING_TIME = 86400  # 1 day in seconds
        
        logger.info("UncertaintyAnalyticsManager initialized successfully")
    
    def load_contracts(self):
        """Load all contracts with verification"""
        logger.info("Loading contracts...")
        
        if not self.w3.is_connected():
            logger.error("No Web3 connection available")
            raise ConnectionError("No Web3 connection available")

        # Create contract instances with predefined ABIs
        try:
            self.uncertainty_contract = self.w3.eth.contract(
                address=self.uncertainty_address, 
                abi=self.uncertainty_abi
            )
            logger.debug(f"UncertaintyAnalytics contract loaded at {self.uncertainty_address}")
            
            self.request_manager_contract = self.w3.eth.contract(
                address=self.request_manager_address, 
                abi=self.request_manager_abi
            )
            logger.debug(f"RequestManager contract loaded at {self.request_manager_address}")
            
            self.response_manager_contract = self.w3.eth.contract(
                address=self.response_manager_address, 
                abi=self.response_manager_abi
            )
            logger.debug(f"ResponseManager contract loaded at {self.response_manager_address}")

            logger.info("All contracts loaded successfully")
            return {
                "uncertainty_contract": self.uncertainty_contract,
                "request_manager_contract": self.request_manager_contract,
                "response_manager_contract": self.response_manager_contract
            }

        except Exception as e:
            logger.error(f"Error loading contracts: {e}", exc_info=True)
            raise

    def validate_contract_functions(self):
        """Validate the existence of key contract functions"""
        logger.info("Validating contract functions...")
        
        # Check UncertaintyAnalytics contract functions
        uncertainty_functions = [
            "calculateUnavailabilityCost",
            "dataHoldingCost",
            "disruptionLevel",
            "getMetrics"
        ]
        
        # Check RequestManager contract functions
        request_manager_functions = [
            "submitRequest",
            "submitRequestWithInfo"
        ]
        
        # Check ResponseManager contract functions
        response_manager_functions = [
            "submitResponse",
            "submitResponseWithCalculation",
            "getResponderCount"
        ]
        
        function_mapping = {
            "UncertaintyAnalytics": (self.uncertainty_contract, uncertainty_functions),
            "RequestManager": (self.request_manager_contract, request_manager_functions),
            "ResponseManager": (self.response_manager_contract, response_manager_functions)
        }
        
        validation_errors = []
        
        for contract_name, (contract, functions) in function_mapping.items():
            for function_name in functions:
                if not hasattr(contract.functions, function_name):
                    error = f"Function {function_name} not found in {contract_name} contract"
                    validation_errors.append(error)
                    logger.error(error)
        
        if validation_errors:
            logger.error(f"Contract function validation failed with {len(validation_errors)} errors")
            return False
        
        logger.info("All contract functions validated successfully")
        return True
    
    def simulate_submit_request(self, value_in_eth: float, additional_info: str = "") -> Dict[str, Any]:
        """Simulate submitting a request with a payment"""
        print(f"Simulating request with value {value_in_eth} ETH...")
        
        # Verify value meets requirements
        if value_in_eth * 10**18 < self.BASE_COST:
            print(f"Error: Value must be at least {Web3.from_wei(self.BASE_COST, 'ether')} ETH")
            return None
        
        request_id = self.next_request_id
        self.next_request_id += 1
        
        value_in_wei = Web3.to_wei(value_in_eth, 'ether')
        timestamp = int(time.time())
        
        request = {
            "id": request_id,
            "requester": self.w3.eth.default_account,
            "timestamp": timestamp,
            "confirmationTime": 0,
            "executionTime": 0,
            "value": value_in_wei,
            "additional_info": additional_info,
            "status": "Pending",
            "is_processed": False,
            "is_valid": True
        }
        
        self.mock_requests[request_id] = request
        self.mock_metrics["totalCost"] += value_in_wei
        
        print(f"\n--- Request Submitted ---")
        print(f"Request ID: {request_id}")
        print(f"Requester: {self.w3.eth.default_account}")
        print(f"Timestamp: {timestamp}")
        print(f"Value: {value_in_eth} ETH")
        if additional_info:
            print(f"Additional Info: {additional_info}")
            
        return request

    def simulate_submit_response(self, request_id: int, with_calculation: bool = False) -> Dict[str, Any]:
        """Simulate submitting a response to a request"""
        print(f"Simulating response for request ID {request_id}...")
        
        if request_id not in self.mock_requests:
            print(f"Error: Request ID {request_id} not found")
            return None
        
        request = self.mock_requests[request_id]
        
        # Check if the request has already been processed (as per ResponseManager contract)
        if request_id in self.mock_processed_requests:
            print(f"Error: Request ID {request_id} already processed")
            return None
        
        if not request["is_valid"]:
            print(f"Error: Request ID {request_id} is not valid")
            return None
            
        if request["status"] != "Pending":
            print(f"Error: Request ID {request_id} is not pending (status: {request['status']})")
            return None
            
        timestamp = int(time.time())
        processing_time = timestamp - request["timestamp"]
        
        response = {
            "request_id": request_id,
            "responder": self.w3.eth.default_account,
            "timestamp": timestamp,
            "processing_time": processing_time,
            "status": "Completed",
            "is_valid": True
        }
        
        # Mark the request as processed
        request["is_processed"] = True
        request["status"] = "Completed"
        request["confirmationTime"] = timestamp
        request["executionTime"] = processing_time
        
        # Store the response
        self.mock_responses[request_id] = response
        
        # Mark as processed in ResponseManager tracking
        self.mock_processed_requests.add(request_id)
        
        # Update responder count (as per ResponseManager contract)
        responder = self.w3.eth.default_account
        self.mock_responder_count[responder] = self.mock_responder_count.get(responder, 0) + 1
        
        print(f"\n--- Response Submitted ---")
        print(f"Request ID: {request_id}")
        print(f"Responder: {responder}")
        print(f"Timestamp: {timestamp}")
        print(f"Processing Time: {processing_time} seconds")
        
        if with_calculation:
            unavailability_cost = 0
            if processing_time > self.MAX_PROCESSING_TIME:  # 1 day in seconds
                # Calculate penalty as per contract logic
                penalty = ((processing_time - self.MAX_PROCESSING_TIME) * self.BASE_COST) // 86400
                unavailability_cost = penalty
                print(f"Calculated Unavailability Cost: {Web3.from_wei(unavailability_cost, 'ether')} ETH")
                response["unavailability_cost"] = unavailability_cost
                
                # Update metrics
                self.mock_metrics["totalCost"] += unavailability_cost
            
        return response

    def simulate_get_metrics(self) -> Dict[str, Any]:
        """Simulate getting metrics from the UncertaintyAnalytics contract"""
        print("Simulating getting metrics...")
        
        # Calculate metrics based on mock data
        if self.mock_responses:
            # Calculate average processing time for valid responses
            total_time = 0
            valid_responses = 0
            
            for response in self.mock_responses.values():
                if response["is_valid"]:
                    total_time += response["processing_time"]
                    valid_responses += 1
            
            if valid_responses > 0:
                self.mock_metrics["avgProcessingTime"] = total_time // valid_responses
            
            # Calculate success rate
            total_requests = len(self.mock_requests)
            completed_requests = sum(1 for req in self.mock_requests.values() if req["status"] == "Completed")
            
            if total_requests > 0:
                self.mock_metrics["successRate"] = (completed_requests * 100) // total_requests
            
            # Disruption count (assuming disruptions are requests with unavailability costs)
            disruption_count = sum(
                1 for resp in self.mock_responses.values() 
                if "unavailability_cost" in resp and resp["unavailability_cost"] > 0
            )
            self.mock_metrics["disruptionCount"] = disruption_count
        
        # Display metrics
        print(f"\n--- Analytics Metrics ---")
        print(f"Average Processing Time: {self.mock_metrics['avgProcessingTime']} seconds")
        print(f"Success Rate: {self.mock_metrics['successRate']}%")
        print(f"Total Cost: {Web3.from_wei(self.mock_metrics['totalCost'], 'ether')} ETH")
        print(f"Disruption Count: {self.mock_metrics['disruptionCount']}")
        
        return self.mock_metrics

    def simulate_get_responder_count(self, responder_address: str) -> int:
        """Simulate getting the number of responses submitted by an address"""
        print(f"Simulating getting responder count for address {responder_address}...")
        
        count = self.mock_responder_count.get(responder_address, 0)
        
        print(f"\n--- Responder Stats ---")
        print(f"Responder: {responder_address}")
        print(f"Response Count: {count}")
        
        return count

    def simulate_record_failed_transaction(self, request_id: int, reason: str) -> bool:
        """Simulate recording a failed transaction"""
        print(f"Simulating recording failed transaction for request ID {request_id} with reason: {reason}")
        
        if request_id not in self.mock_requests:
            print(f"Error: Request ID {request_id} not found")
            return False
        
        request = self.mock_requests[request_id]
        request["status"] = "Failed"
        request["failure_reason"] = reason
        
        # Update metrics
        self.mock_metrics["successRate"] = (
            (len([r for r in self.mock_requests.values() if r["status"] == "Completed"]) * 100) 
            // len(self.mock_requests)
        )
        
        print(f"\n--- Failed Transaction Recorded ---")
        print(f"Request ID: {request_id}")
        print(f"Reason: {reason}")
        print(f"Updated Success Rate: {self.mock_metrics['successRate']}%")
        
        return True

    def submit_request(self, value_in_eth: float, additional_info: str = "") -> int:
        """Submit a request to the UncertaintyAnalytics contract with payment"""
        print(f"Submitting request with value {value_in_eth} ETH...")
        value_in_wei = Web3.to_wei(value_in_eth, 'ether')
        
        # Verify minimum value
        if value_in_wei < self.BASE_COST:
            error_msg = f"Error: Value must be at least {Web3.from_wei(self.BASE_COST, 'ether')} ETH"
            self.logger.error(error_msg)
            print(error_msg)
            return 0
            
        try:
            # Get nonce
            nonce = self.w3.eth.get_transaction_count(self.w3.eth.default_account)
            print(f"Got nonce: {nonce}")
            
            # Prepare transaction parameters
            tx_params = {
                'from': self.w3.eth.default_account,
                'value': value_in_wei,
                'nonce': nonce,
                'gas': 200000,
                'gasPrice': self.w3.eth.gas_price
            }
            print("Transaction parameters prepared")
            
            if additional_info:
                # Use RequestManager's submitRequestWithInfo
                print(f"Using submitRequestWithInfo with info: {additional_info}")
                tx = self.request_manager_contract.functions.submitRequestWithInfo(
                    additional_info
                ).build_transaction(tx_params)
            else:
                # Use standard submitRequest
                print("Using standard submitRequest")
                tx = self.request_manager_contract.functions.submitRequest().build_transaction(tx_params)
            
            # Get private key from environment variables
            private_key = os.getenv('PRIVATE_KEY')
            if not private_key:
                raise ValueError("PRIVATE_KEY not found in environment variables")
            
            # Add '0x' prefix if it's missing
            if not private_key.startswith('0x'):
                private_key = '0x' + private_key
            print("Got private key from environment")
                
            # Sign and send transaction
            print("Signing transaction...")
            signed_tx = self.w3.eth.account.sign_transaction(tx, private_key)
            print("Sending transaction...")
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
            
            print(f"Transaction hash: {tx_hash.hex()}")
            
            # Wait for transaction receipt
            print("Waiting for transaction receipt...")
            tx_receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            print(f"Transaction status: {'Success' if tx_receipt['status'] == 1 else 'Failed'}")
            
            # Parse event logs to get the request ID
            if tx_receipt['status'] == 1:
                print("Transaction successful. Looking for RequestSubmitted event...")
                # Look for RequestSubmitted event
                event_signature = self.request_manager_contract.events.RequestSubmitted().event_signature_hash
                for log in tx_receipt['logs']:
                    if log['topics'][0].hex() == event_signature:
                        # Parse the logs to get the request ID
                        parsed_logs = self.request_manager_contract.events.RequestSubmitted().process_receipt(tx_receipt)
                        request_id = parsed_logs[0]['args']['requestId']
                        print(f"Request ID: {request_id}")
                        return request_id
            
            return 0  # Request failed
            
        except Exception as e:
            self.logger.error(f"Error submitting request: {e}")
            print(f"Error submitting request: {e}")
            raise

    def submit_response(self, request_id: int, with_calculation: bool = False) -> bool:
        """Submit a response to a request via the ResponseManager contract"""
        print(f"Submitting response for request ID {request_id}...")
        try:
            # Get nonce
            nonce = self.w3.eth.get_transaction_count(self.w3.eth.default_account)
            print(f"Got nonce: {nonce}")
            
            # Prepare transaction parameters
            tx_params = {
                'from': self.w3.eth.default_account,
                'nonce': nonce,
                'gas': 200000,
                'gasPrice': self.w3.eth.gas_price
            }
            print("Transaction parameters prepared")
            
            if with_calculation:
                # Use submitResponseWithCalculation
                print("Using submitResponseWithCalculation")
                tx = self.response_manager_contract.functions.submitResponseWithCalculation(
                    request_id
                ).build_transaction(tx_params)
            else:
                # Use standard submitResponse
                print("Using standard submitResponse")
                tx = self.response_manager_contract.functions.submitResponse(
                    request_id
                ).build_transaction(tx_params)
            
            # Get private key from environment variables
            private_key = os.getenv('PRIVATE_KEY')
            if not private_key:
                raise ValueError("PRIVATE_KEY not found in environment variables")
            
            # Add '0x' prefix if it's missing
            if not private_key.startswith('0x'):
                private_key = '0x' + private_key
            print("Got private key from environment")
                
            # Sign and send transaction
            print("Signing transaction...")
            signed_tx = self.w3.eth.account.sign_transaction(tx, private_key)
            print("Sending transaction...")
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
            
            print(f"Transaction hash: {tx_hash.hex()}")
            
            # Wait for transaction receipt
            print("Waiting for transaction receipt...")
            tx_receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            print(f"Transaction status: {'Success' if tx_receipt['status'] == 1 else 'Failed'}")
            
            return tx_receipt['status'] == 1
            
        except Exception as e:
            self.logger.error(f"Error submitting response: {e}")
            print(f"Error submitting response: {e}")
            raise

    def get_metrics(self) -> Dict[str, Any]:
        """Get metrics from UncertaintyAnalytics contract"""
        print("Getting metrics from UncertaintyAnalytics contract...")
        try:
            metrics = self.uncertainty_contract.functions.getMetrics().call()
            
            result = {
                "avgProcessingTime": metrics[0],
                "successRate": metrics[1],
                "totalCost": metrics[2],
                "disruptionCount": metrics[3]
            }
            
            print(f"\n--- Analytics Metrics ---")
            print(f"Average Processing Time: {result['avgProcessingTime']} seconds")
            print(f"Success Rate: {result['successRate']}%")
            print(f"Total Cost: {Web3.from_wei(result['totalCost'], 'ether')} ETH")
            print(f"Disruption Count: {result['disruptionCount']}")
            
            return result
            
        except Exception as e:
            self.logger.error(f"Error getting metrics: {e}")
            print(f"Error getting metrics: {e}")
            raise

    def get_responder_count(self, responder_address: str) -> int:
        """Get the number of responses submitted by an address"""
        print(f"Getting responder count for address {responder_address}...")
        try:
            count = self.response_manager_contract.functions.getResponderCount(
                Web3.to_checksum_address(responder_address)
            ).call()
            
            print(f"\n--- Responder Stats ---")
            print(f"Responder: {responder_address}")
            print(f"Response Count: {count}")
            
            return count
            
        except Exception as e:
            self.logger.error(f"Error getting responder count: {e}")
            print(f"Error getting responder count: {e}")
            raise

    def record_failed_transaction(self, request_id: int, reason: str) -> bool:
        """Record a failed transaction"""
        print(f"Recording failed transaction for request ID {request_id} with reason: {reason}")
        try:
            # Get nonce
            nonce = self.w3.eth.get_transaction_count(self.w3.eth.default_account)
            print(f"Got nonce: {nonce}")
            
            # Prepare transaction parameters
            tx_params = {
                'from': self.w3.eth.default_account,
                'nonce': nonce,
                'gas': 200000,
                'gasPrice': self.w3.eth.gas_price
            }
            print("Transaction parameters prepared")
            
            tx = self.uncertainty_contract.functions.recordFailedTransaction(
                request_id, reason
            ).build_transaction(tx_params)
            
            # Get private key from environment variables
            private_key = os.getenv('PRIVATE_KEY')
            if not private_key:
                raise ValueError("PRIVATE_KEY not found in environment variables")
            
            # Add '0x' prefix if it's missing
            if not private_key.startswith('0x'):
                private_key = '0x' + private_key
            print("Got private key from environment")
                
            # Sign and send transaction
            print("Signing transaction...")
            signed_tx = self.w3.eth.account.sign_transaction(tx, private_key)
            print("Sending transaction...")
            tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
            
            print(f"Transaction hash: {tx_hash.hex()}")
            
            # Wait for transaction receipt
            print("Waiting for transaction receipt...")
            tx_receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            print(f"Transaction status: {'Success' if tx_receipt['status'] == 1 else 'Failed'}")
            
            return tx_receipt['status'] == 1
            
        except Exception as e:
            self.logger.error(f"Error recording failed transaction: {e}")
            print(f"Error recording failed transaction: {e}")
            raise

    def visualize_metrics(self, save_path: Optional[str] = None) -> None:
        """Visualize analytics metrics"""
        print("Visualizing analytics metrics...")
        try:
            # Get metrics, either from simulation or real contract
            if hasattr(self.uncertainty_contract.functions, 'getMetrics'):
                metrics = self.get_metrics()
            else:
                metrics = self.simulate_get_metrics()
            
            # Create a DataFrame for easier visualization
            metrics_data = {
                'Metric': ['Avg Processing Time (s)', 'Success Rate (%)',  'Total Cost (ETH)', 'Disruption Count'],
                'Value': [
                    metrics['avgProcessingTime'],
                    metrics['successRate'],
                    Web3.from_wei(metrics['totalCost'], 'ether'),
                    metrics['disruptionCount']
                ]
            }
            df = pd.DataFrame(metrics_data)
            
            # Create visualizations
            fig, axes = plt.subplots(2, 2, figsize=(14, 10))
            axes = axes.flatten()
            
            # Plot 1: Average Processing Time
            axes[0].bar(['Avg Processing Time'], [metrics['avgProcessingTime']], color='blue')
            axes[0].set_ylabel('Seconds')
            axes[0].set_title('Average Processing Time')
            axes[0].grid(axis='y', linestyle='--', alpha=0.7)
            
            # Plot 2: Success Rate
            axes[1].bar(['Success Rate'], [metrics['successRate']], color='green')
            axes[1].set_ylabel('Percentage (%)')
            axes[1].set_title('Success Rate')
            axes[1].set_ylim(0, 100)
            axes[1].grid(axis='y', linestyle='--', alpha=0.7)
            
            # Plot 3: Total Cost
            axes[2].bar(['Total Cost'], [float(Web3.from_wei(metrics['totalCost'], 'ether'))], color='red')
            axes[2].set_ylabel('ETH')
            axes[2].set_title('Total Cost')
            axes[2].grid(axis='y', linestyle='--', alpha=0.7)
            
            # Plot 4: Disruption Count
            axes[3].bar(['Disruption Count'], [metrics['disruptionCount']], color='orange')
            axes[3].set_title('Disruption Count')
            axes[3].grid(axis='y', linestyle='--', alpha=0.7)
            
            plt.tight_layout()
            
            # Save if path provided
            if save_path:
                plt.savefig(save_path)
                print(f"Visualization saved to {save_path}")
            
            # Show plot
            plt.show()
            
        except Exception as e:
            self.logger.error(f"Error visualizing metrics: {e}")
            print(f"Error visualizing metrics: {e}")
            
